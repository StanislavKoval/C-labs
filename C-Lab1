//РАБОТА СО СТРОКАМИ Ч.1

//символ
char sym;
sym='A';

//Cтрока в СИ – это последовательность символов.

//Рассмотрим механизм создания строк

// Строка - массив из 10 символов. Начальное значение символов не определено.
char str1[10];

//В первые 5 символов записывается “Hello”, в 6 – нуль-терминатор ('\0'), а значение трех последних не определено.
char str2[10]="Hello";// Используется инициализация (не присваивание!). 

char str3[10]={'H', 'e', 'l', 'l', 'o', '\0'}; //Эквивалентно предыдущему “Hello” .

char str4[10]="Very long line";//Ошибка!. Массив из 10 элементов нельзя инициировать более длинной последовательностью.

//Компилятор автоматически определяет длину массива (в нашем случае 15) и инициализирует его последовательностью символов.
char str5[]="Very long line";

//Строка - указатель на символ. В большинстве случаев для ее использования потребуется выделить память.
char* str6; 
str6=(char*) malloc(10);
free(str6);//освобождаем ресурсы указателя

//Компиляция
int main(){
	
    char A[5] = "abcd";
    char B[5] = {'a','b','c','d','\0'};//эквивалентные записи
    printf("String1: %s\n", A);
    printf("String2: %s\n", B);
    
    //рассмотрим метод str_len()
    int len; 
    len = str_len(A);               //вызов метода str_len(A), сам метод описан ниже
    printf("length n: %d\n", len);  //вывод длинны строки
    
    //добавляем символ
    A[len] = 'd';
    printf("String: %s\n", A);
    
    //заменяя выбранный символ нуль-терминатором, заканчиваем чтение строки
    A[2] = '\0';
    printf("String: %s\n", A);
    
    //замена символа в строке
    A[2] = 'y';
    printf("String: %s\n", A);
    
    //вывод отдельного символа
    printf("Char: %c\n", A[3]);
    
    printf("%d\n", 'a' < 'c');//print возвращает 0 или 1
    
    getchar();
    return 0;
}

//метод str_len, возвращает длинну строки. Реализация метода str_len.
int str_len(char* str) {        //задаем функцию
    int i = 0;                  //инициализируем переменную счетчика
    while (str[i++] != '\0');   //организуем цикл
    return i-1;                 //возвращаем значение
}

//******************************************************************************************************************************

//ЗАДАНИЕ
//Реализовать на языке С данные методы

//метод str_cpy. Копирует посимвольно из исходной строки src[i] в dst[i]
---char* str_cpy(char* dst, char* src);

//метод str_cat. К концу первой строки прибавляет вторую строку
---char* str_cat(char* str1, char* str2);

//метод str_cmp. Сравнивает строки, возвращает индекс с одним из 3-х значений (-1;0;1) (<;=;>) соотв.
---int str_cmp(char* str1, char* str2);

//метод str_str. Поиск строки sub в str, возвращает индексы i. Если отсутствует, то Null. Реализация имеет метод break.
---char* str_str(char* str, char* sub);

//метод char_in_string. Поиск символа symbol в string, возвращает его индекс i, если отсутствует, то Null.
---unsigned char_in_string(char symbol, char* str);

//Время на выполнения 90 минут или 5400 секунд, если вы любите СИ ;)
//******************************************************************************************************************************





































































//РЕШЕНИЕ
//******************************************************************************************************************************
//метод str_cpy
char* str_cpy(char* dst, char* src);

//реализация str_cpy
char* str_cpy(char* dst, char* src)
{
    unsigned i = 0;
    do
        dst[i] = src[i];
    while (src[i++]);
 
    return dst;
}
//******************************************************************************************************************************
//метод str_cat
char* str_cat(char* str1, char* str2);

//реализация str_cpy
char* str_cat(char* str1, char* str2)
{
    unsigned str1_len = str_len(str1);
    unsigned i = 0;
    do
        str1[i + str1_len] = str2[i];
    while (str2[i++]);
    return str1;
 }  
 
 // еще одна из возможных реализаций на базе полученных ранее методов str_len и str_cpy
 char* str_cat(char* str1, char* str2)
 {   
   return str_cpy(str1 + str_len(str1), str2);
 }
//******************************************************************************************************************************
//метод str_cmp
int str_cmp(char* str1, char* str2);

//реализация str_cmp
int str_cmp(char* str1, char* str2)
{
    unsigned i = 0;
    int delta;
    do
    {
        delta = str1[i] - str2[i];
    } while (!delta && str1[i++]);
    return (delta);
}
//******************************************************************************************************************************
//метод str_str
char* str_str(char* str, char* sub);

//реализация str_str
char* str_str(char* str, char* sub)
{
    unsigned i = 0, j, flag;
    do
    {
        j = 0;
        flag = 1;
        do
            if (str[i + j] != sub[j])
            {
                flag = 0;
                break;
            }
        while (sub[++j]);
        if (flag) return (str + i);
    } while (str[i++]);
 
    return NULL;
}
//******************************************************************************************************************************
//метод char_in_string
unsigned char_in_string(char symbol, char* str);

//реализация char_in_string
unsigned char_in_string(char symbol, char* str)
{
    unsigned i = 0;
 
    do
        if (str[i] == symbol)
            return 1;
    while (str[i++]);
 
    return 0;
}

//******************************************************************************************************************************
//Методы s_gets и s_gets_c чтения строки с консоли


char* s_gets(char* str, unsigned buf_size)
{
    /*
    Безопасная (с точки зрения риска переполненя буфера)
    реализация чтения строки с консоли
    Является обёрткой вызова функции fgets
    */
 
    unsigned i = 0;
    //если вызов fgets завершился возвратом NULL
    if (!fgets(str, buf_size, stdin))
        //тоже вернём NULL - признак ошибки ввода
        return NULL;
 
    //fgets не вырезает символ перевода строки
    //это удобно для файлов, а при вводе с клавиатуры
    //придётся сделать это самим
    do
        if (str[i] == '\n')
            break;
    while (str[++i]);
 
    //символ конца строки впишем на ту позицию,
    //на которой остановился цикл
    //это будет либо при чтении '\0', либо '\n'
    str[i] = '\0';
 
    //часто дополнительно обрабатывают ситуацию,
    //когда fgets завершился, поскольку исчерпан буфер
    //при этом вычитывают всё, что осталось в потоке ввода
    //обратите внимание, что тело цикла пусто
    //вся полезная работа делается в ходе проверки условия
    //за счёт вызова getchar
    while (getchar() != '\n');
 
    return str;
}


char* s_gets_c(char* str, unsigned buf_size)
{
    /*
    Безопасная (с точки зрения риска переполненя буфера)
    реализация чтения строки с консоли
    Основана на посимвольном чтении потока ввода (getchar)
    */
 
    unsigned i = 0;
    int ch;
 
    //в данном случае из потока ввода забираем всё,
    // что есть до символа '\n' (когда будет нажат ввод)
    while ((ch = getchar()) != '\n')
        //но записываем только пока есть место в строке
        if (i < (buf_size - 1))
            str[i++] = ch;
    //в конце не забываем поставить символ конца строки
    str[i] = '\0';
 
    return str;
}
 
//ИТОГИ
/*
1.Разобрали понятие строки в СИ и рассмотрели механизмы их создание 
2.Рассмотрели различные методы работы со строками
3.Освоили методы s_gets и s_gets_c
4.Поняли, что строки в СИ это слооооооооооооожно, потому учите Python, там это 1 строка ;)
*/













//******************************************************************************************************************************
//******************************************************************************************************************************
//******************************************************************************************************************************
//******************************************************************************************************************************
//******************************************************************************************************************************


ИСХОДНИКИ


// ConsoleApplication1.cpp: определяет точку входа для консольного приложения.
//

#include "stdafx.h"

int str_len(char* str);

char* s_gets(char* str, unsigned buf_size);		
char* s_gets_c(char* str, unsigned buf_size);

char* str_cpy(char* dst, char* src);
char* str_cat(char* str1, char* str2);
int str_cmp(char* str1, char* str2);
char* str_str(char* str, char* sub);
unsigned char_in_string(char symbol, char* str);

int main()
{
	const int n = 50;
	char A[n] = "abcd";
	printf("String: %s\n", A);
	int len = str_len(A);
	printf("Len: %d\n", len);
	printf("%d\n", 'a' > 'b');
	A[len] = 'd';
	printf("String: %s\n", A);
	A[2] = '\0';
	A[2] = 'y';
	printf("String: %s\n", A);
	printf("Char: %c\n", A[3]);
	getchar();
	return 0;
}

int str_len(char* str) {
	int i = 0;
	while (str[i++] != '\0');
	return i-1;
}

char* s_gets(char* str, unsigned buf_size)
{
	/*
	Безопасная (с точки зрения риска переполненя буфера)
	реализация чтения строки с консоли
	Является обёрткой вызова функции fgets
	*/

	unsigned i = 0;
	//если вызов fgets завершился возвратом NULL
	if (!fgets(str, buf_size, stdin))
		//тоже вернём NULL - признак ошибки ввода
		return NULL;

	//fgets не вырезает символ перевода строки
	//это удобно для файлов, а при вводе с клавиатуры
	//придётся сделать это самим
	do
		if (str[i] == '\n')
			break;
	while (str[++i]);

	//символ конца строки впишем на ту позицию,
	//на которой остановился цикл
	//это будет либо при чтении '\0', либо '\n'
	str[i] = '\0';

	//часто дополнительно обрабатывают ситуацию,
	//когда fgets завершился, поскольку исчерпан буфер
	//при этом вычитывают всё, что осталось в потоке ввода
	//обратите внимание, что тело цикла пусто
	//вся полезная работа делается в ходе проверки условия
	//за счёт вызова getchar
	while (getchar() != '\n');

	return str;
}

char* s_gets_c(char* str, unsigned buf_size)
{
	/*
	Безопасная (с точки зрения риска переполненя буфера)
	реализация чтения строки с консоли
	Основана на посимвольном чтении потока ввода (getchar)
	*/

	unsigned i = 0;
	int ch;

	//в данном случае из потока ввода забираем всё,
	// что есть до символа '\n' (когда будет нажат ввод)
	while ((ch = getchar()) != '\n')
		//но записываем только пока есть место в строке
		if (i < (buf_size - 1))
			str[i++] = ch;
	//в конце не забываем поставить символ конца строки
	str[i] = '\0';

	return str;
}

char* str_cpy(char* dst, char* src)
{
	unsigned i = 0;
	do
		dst[i] = src[i];
	while (src[i++]);

	return dst;
}

char* str_cat(char* str1, char* str2)
{
	unsigned str1_len = str_len(str1);
	unsigned i = 0;
	do
	str1[i + str1_len] = str2[i];
	while (str2[i++]);

	return str1;

	//return str_cpy(str1 + str_len(str1), str2);
}

int str_cmp(char* str1, char* str2)
{
	unsigned i = 0;
	int delta;


	do
	{
		delta = str1[i] - str2[i];
	} while (!delta && str1[i++]);
	return (delta);
}

char* str_str(char* str, char* sub)
{
	unsigned i = 0, j, flag;

	do
	{
		j = 0;
		flag = 1;
		do
			if (str[i + j] != sub[j])
			{
				flag = 0;
				break;
			}
		while (sub[++j]);
		if (flag) return (str + i);
	} while (str[i++]);

	return NULL;
}



unsigned char_in_string(char symbol, char* str)
{
	unsigned i = 0;

	do
		if (str[i] == symbol)
			return 1;
	while (str[i++]);

	return 0;
}

Онлайн компилятор: https://ideone.com/tVrHO6
