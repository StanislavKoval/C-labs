//РАБОТА СО СТРОКАМИ Ч.2

//Повторение
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
#include <stdio.h>

//метод str_len, возвращает длинну строки
int str_len(char* str) {
	
    int i = 0;
    while (str[i++] != '\0');
    return i-1;//т.к. отсчет начинался с 0
    
}

//метод str_cpy, посимвольно копирует строку src в dst, возвращая скопированную строку
	//небезопасен, т.к. отсутствует проверка на переполнение памяти
char* str_cpy(char* dst, char* src){
	
	unsigned i = 0;
	do
		dst[i] = src[i];
	while (src[i++]);
	return dst;

}

//метод str_cat, содержимое строки str1 дописывается после str1
	//небезопасен, т.к. отсутствует проверка на переполнение памяти
char* str_cat(char* str1, char* str2){

	unsigned str1_len = str_len(str1);//используем ранее изученный метод str_len
	unsigned i = 0;
	
	do
		str1[i + str1_len] = str2[i];
	while (str2[i++]);
	
	return str1;
	
return str_cpy(str1 + str_len(str1), str2);
}

//метод str_cmp, сравнивает 2 строки посимвольно, возвращая величину int !
	//Случай 1: строки абсолютно идентичны, возвращай 0
	//Случай 2: символ строки str1 больше по кодировке, чем символ строки str2, возвращай число>0
	//Случай 3: символ строки str2 больше по кодировке, чем символ строки str1, возвращай число<0
int str_cmp(char* str1, char* str2){

	unsigned i = 0;
	int delta;

	do
	{
		delta = str1[i] - str2[i];
	} while (!delta && str1[i++]);
	//while идет на новый круг только тогда, когда delta=0 - > !delta=1 -> 1&&1=1 -> след. круг
	//если delta !=0, то есть delta=1, тогда !delta=0 и 0&&1=0, цикл остановится
	return (delta); 
}

//метод str_str, ищет строку sub в строке str, 
	//возвращает указатель на символ с которого началось совпадение, 
	//в случае отсутствия возвращает значнеи NULL
char* str_str(char* str, char* sub){
	
	unsigned i = 0, j, flag;

	do
	{
		j = 0;
		flag = 1;
		do 
			//если нашли несовпадающие символы
			if (str[i + j] != sub[j])
			{
				//сбросили флаг и вышли
				flag = 0;
				break;
			}
		
		while (sub[++j]);//увеличиваем перед проверкой условия
		if (flag) 
			return (str+i);
	} while (str[i++]);

	return NULL;
}

//метод char_in_string, проверяет, есть ли в строке символ symbol или нет
	//возвращая 1, если есть или 0, если нет
	//нужен для проверки наличия '\0' в строке
unsigned char_in_string(char symbol, char* str){
	
	unsigned i = 0;
	
	do
		if (str[i] == symbol)
			return 1;
	while (str[i++]);

	return 0;
}

//метод s_gets на базе fgets
	//безопасная с точки зрения переполнения буфера
	//реализация чтения строки с консоли
		//Функция fgets() считывает до num-1 символов из файла stream
		//и помещает их в массив символов, на который указывает str. 
		//Символы считываются до тех пор, пока не встретится символ «новая строка»
		//Чтение происходит из файла.
char* s_gets(char* str, unsigned buf_size){

	unsigned i = 0;
	//если вызов fgets завершился возвратом NULL
	if (!fgets(str, buf_size, stdin))//функцию fgets вы уже знаете
		return NULL;

	do
		if (str[i] == '\n')
			break;
	while (str[++i]);
	
	str[i] = '\0';

	while (getchar() != '\n');

	return str;
}

//метод s_gets_c на базе getchar
//безопасная с точки зрения переполнения буфера
//Основана на посимвольном чтении потока ввода (getchar)
char* s_gets_c(char* str, unsigned buf_size){
	
	unsigned i = 0;
	int ch;

	//в данном случае из потока ввода забираем всё,
	// что есть до символа '\n' (когда будет нажат ввод)
	while ((ch = getchar()) != '\n')
		//но записываем только пока есть место в строке
		if (i < (buf_size - 1))
			str[i++] = ch;
	//в конце не забываем поставить символ конца строки
	str[i] = '\0';
		
	return str;
}


int main(void) {

	//создадим в качестве входных данных 3 строки
	char A[] = "aaaa";
	char B[] = "bbbb";
	char C[] = "c";
	char empty[50];
	
	//применение метода str_len
	int len; 
    len = str_len(A);
	printf("length of A: %d\n", len); 
	
	//применение метода str_сpy
    str_cpy(B,A);// мы записали значение А в В
	printf("str_cpy result: %s\n", B);//не забываем, что тип str и поэтому %s !
	
	//применение метода str_cat
    str_cat(B,C);
	printf("str_cat result: %s\n", B);// str B + str C = aaaac (выше мы изменили значение str B)
	
	//применение метода str_cmp
	int i1 = str_cmp(A,A);//0
	int i2 = str_cmp(B,A);//>0
	int i3 = str_cmp(A,C);//<0
	
	printf("str_cmp result: 1) %d\n", i1);// не забудь про %d
	printf("str_cmp result: 2) %d\n", i2);// не забудь про %d
	printf("str_cmp result: 3) %d\n", i3);// не забудь про %d
	
	//применение метода str_str
	printf("str_str result: %s\n", str_str(B, C));	//повтор sub (в нашем случае C) 
													//в str (в нашем случае В) начинается с 'с'
	printf("str_str result: %s\n", str_str(A, C));	//'c' отсутствует в A, возвращаем (null)
	
	//применение char_in_string
	unsigned char symbol = '\0';
	printf("char_in_string result: %d\n", char_in_string(symbol, A));//%d т.к. в return значенеи int 
	
	return 0;
}

//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
//СЕГОДНЯ В МЕНЮ

1)unsigned sum_of_digits(char* str);			                //сумма цифр в строке
  //Пример: "12string34" -> 10
2)unsigned sum_of_decimals(char* str);		                        //сумма чисел в строке
  //Пример: "12string34" -> 46
3)unsigned words_count(char* str);		                        //подсчёт числа слов в строке
  //Пример: "Мама мыла раму" -> 3
4)char* remove_char(char* str, unsigned pos);	                    	//удаление символа в заданной позиции со сдвигом
  //Пример: "Мама мыла раму",2 -> 'a'-> "Ммa мылa рaму"          	//c учетом сдвига
5)char* remove_duplicates(char* str);			                //удаление дубликатов символов
  //Пример: "Миру Мир" -> "М","и","р","у"," "-> "Миру "
6)char* reverse_string(char* str)			                //перестановка симовлов в обратном порядке
  //Пример: "РОЗУ" - > "УЗОР"
7)char* reverse_substring(char* str, int left, int right)	        //перестановка символов в строке в заданных пределах
  //Пример: "Карета" - > "раКета" от 0 до 2
  
//ДОП. ЗАДАЧИ -> ДЗ
/*
1)Шифрование. Сделать шифрование строки по следующему примеру: aaAAAbbCCCCxY - >2a3A2b4CxY
2)Представление Арабских чисел в виде Римских. Диапозон от 1 до 4000. Пример: 13 ->XIII, 500 -> D
3)Представление Римских чисел в виде Арабских. Диапозон от 1 до 4000. Пример: DC ->600, CXIII -> 113
/*
//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


//ОТВЕТЫ
1)
unsigned sum_of_digits(char* str)
{
	/*
	Функция вычисления суммы ЦИФР,
	входящих в состав строки
	*/
	unsigned i = 0, sum = 0;

	do
		//если символ является цифрой
		if (str[i] >= '0' && str[i] <= '9')
			//добавляем значение цифры к сумме
			//поскольку в кодовой таблице цифры
			//записаны подряд, числовое значение
			//можно получить вычислив разность
			//кода текущего символа с кодом символа '0'
			sum += str[i] - '0';
	while (str[i++]);

	return sum;
}

2)
unsigned sum_of_decimals(char* str)
{
	/*
	Функция вычисления суммы ЧИСЕЛ,
	входящих в состав строки
	*/

	unsigned i = 0, sum = 0, decimal = 0;

	do
	{
		//пока встречаем в подряд идущие цифры
		while (str[i] >= '0' && str[i] <= '9')
		{
			//формируем число
			decimal = decimal * 10 + (str[i] - '0');
			i++;
		}
		//если символ не цифра
		//добавляем подсчитанное число к сумме
		sum += decimal;
		//и готовимся читать следующее число
		decimal = 0;
	}
	while (str[i++]);

	return sum;
}

3)
unsigned words_count(char* str)
{
	/*
	Функция расчёта числа слов в строке
	Слова отделяются символами-разделителями,
	которые для удобства сгруппированы в отдельную
	строку separator. В некоторых случаях удобно
	передавать такую строку как второй аргумент функции.
	При написании подобных функций важно помнить,
	что она должна быть устойчива к появлению разделителей
	в начале строки, нескольких разделителей вподряд,
	корректно обрабатывать слово, за которым следует
	конец строки
	*/

	unsigned inWord = 0, i = 0, count = 0;
	char separator[] = " \t,.!?:;";

	do
	{
		if (char_in_string(str[i], separator))
		{
			if (inWord)
				count++;
			inWord = 0;
		}
		else
			inWord = 1;
	} while (str[i++]);
	//при этом символ '\0' тоже будет обработан

	return count;
}

4)
char* remove_char(char* str, unsigned pos)
{
	/*
	Функция удаления символа с заданным индексом
	*/

	//реализцетя по сути сдвиг вправо,
	//начиная с заданной позиции
	do
		str[pos] = str[pos + 1];
	while (str[pos++]);
	//только цикл организоваy на основе проверки на '\0'

	//и возвращаем char*,
	//как это обычно делается в функциях обработки строк
	return str;
}

5)
char* remove_duplicates(char* str)
{
	/*
	Функция удаления повторных вхождений символов в строку
	Простейшие реализации обычно основаны
	на удалении найденных повторных символов,
	что приводит к многократным сдвигам массива
	В данной реализации повторные символы не удаляются,
	а просто пропускаются.
	Зато впервые встреченные символы копируются в начало строки.
	Т.е. в начале строки начинает формироваться ответ,
	по завершении обработки всей строки после него надо будет
	только дописать '\0'.
	Тем самым мы не только избегаем сдвигов,
	но и упрощаем процедуру проверки на дубликаты.
	Уникальных символов заведомо не может быть больше,
	чем всего символов в кодовой таблице (255).
	А строка при этом может быть гораздо длиннее.
	Важно заметить, что в общем случае счётчик символов i
	обгоняет счётчик уникальных символов count,
	но между ними располагаются дублирующиеся элементы,
	поэтому на их место можно смело записывать новые обнаруженные
	уникальные элементы
	*/

	unsigned count = 1, i = 0, j, flag;
	
	while (str[i])
	{
		flag = 1;
		//проверка на унивальность
		//поиск среди первых (count-1) элементов
		for (j=0; j < count; j++)
			if (str[j] == str[i])
			{
				flag = 0;
				break;
			}
		//если флаг не сброшен
		if (flag)
			//добавляем символ к числу уникальных			
			str[count++] = str[i];
		i++;
	}
	str[count] = '\0';

	return str;

}


7.1)
char* reverse_substring(char* str, int left, int right)
{
	/*
	Переворот подстроки
	В начале возможно добавление проверки
	на корректность исходных данных
	(left и right)
	*/

	while (left < right)
		swap(str + left++, str + right--);
	
	return str;
}
7.2)
char* reverse_string(char* str)
{
	/*
	Переворот строки
	*/

	//сводится к перевороту подстроки,
	//но захватывая все элементы строки
	return reverse_substring(str, 0, str_len(str)-1);
}

























































































//+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
ИСХОДНИКИ

#include <stdio.h>
//#include <string.h>		//подключаем, если нужно подсмотреть определение стандартных функций обработки строк

char* s_gets(char* str, unsigned buf_size);		//безопасная реализация gets на базе fgets
char* s_gets_c(char* str, unsigned buf_size);		//безопасная реализация gets на базе getchar
unsigned str_len(char* str);				//определение длины строки
char* str_cpy(char* dst, char* src);		//копированис строки
char* str_cat(char* str1, char* str2);		//сцепление строк
int str_cmp(char* str1, char* str2);		//сравнение строк
char* str_str(char* str, char* sub);		//поиск подстроки в строке

char* remove_char(char* str, unsigned pos);	//удаление символа в заданной позиции со сдвигом
char* remove_duplicates(char* str);			//удаление дубликатов символов

unsigned sum_of_digits(char* str);			//сумма цифр в строке
unsigned sum_of_decimals(char* str);		//сумма чисел в строке

void swap(char* pa, char* pb);				//обмен значениями между переменными

char* reverse_string(char* str);			//перестановка всех символов строки в обратном порядке
char* reverse_substring(char* str, int left, int right);	//перестановка символов в заданном диапазане индексов 

unsigned char_in_string(char symbol, char* str);	//определяем вхождение символа в строку
unsigned words_count(char* str);		//подсчёт числа слов в строке
unsigned longest_word(char* str);		//определение длины самого длинного слова в строке
unsigned shortest_word(char* str);		//определение длины самого короткого слова в строке
void print_words(char* str);			//распечатка слов строки по отдельности
char* reverse_words(char* str);			//перестановка символов внутри каждого слова

int main()
{
	const unsigned buf_size = 50;
	char str1[buf_size];
	char str2[buf_size];

	s_gets_c(str1, buf_size);
	//s_gets(str2, buf_size);

	//printf("%u", sum_of_digits(str1));
	//printf("%u", sum_of_decimals(str1));

	//puts(remove_duplicates(str1));
	//puts(reverse_string(str1));
	
	puts(str1);
	puts(reverse_words(str1));

	//print_words(str1);
	//printf("%u", shortest_word(str1));

	getchar();
    return 0;
}

char* s_gets(char* str, unsigned buf_size)
{
	/*
	Безопасная (с точки зрения риска переполненя буфера)
	реализация чтения строки с консоли
	Является обёрткой вызова функции fgets
	*/

	unsigned i = 0;
	//если вызов fgets завершился возвратом NULL
	if (!fgets(str, buf_size, stdin))
		//тоже вернём NULL - признак ошибки ввода
		return NULL;

	//fgets не вырезает символ перевода строки
	//это удобно для файлов, а при вводе с клавиатуры
	//придётся сделать это самим
	do
		if (str[i] == '\n')
			break;
	while (str[++i]);
		
	//символ конца строки впишем на ту позицию,
	//на которой остановился цикл
	//это будет либо при чтении '\0', либо '\n'
	str[i] = '\0';

	//часто дополнительно обрабатывают ситуацию,
	//когда fgets завершился, поскольку исчерпан буфер
	//при этом вычитывают всё, что осталось в потоке ввода
	//обратите внимание, что тело цикла пусто
	//вся полезная работа делается в ходе проверки условия
	//за счёт вызова getchar
	while (getchar() != '\n');

	return str;
}

char* s_gets_c(char* str, unsigned buf_size)
{
	/*
	Безопасная (с точки зрения риска переполненя буфера)
	реализация чтения строки с консоли
	Основана на посимвольном чтении потока ввода (getchar)
	*/

	unsigned i = 0;
	int ch;

	//в данном случае из потока ввода забираем всё,
	// что есть до символа '\n' (когда будет нажат ввод)
	while ((ch = getchar()) != '\n')
		//но записываем только пока есть место в строке
		if (i < (buf_size - 1))
			str[i++] = ch;
	//в конце не забываем поставить символ конца строки
	str[i] = '\0';
		
	return str;
}

unsigned str_len(char* str)
{
	/*
	Функция определения длины строки
	считается, что на вход подаётся правильно сформированная строка
	(завершающаяся '\0')
	контроллировать размер буфера не требуется,
	т.к. мы гарантированно не будем менять стороку
	*/

	unsigned i = 0;
	//обратите внимание, что тело цикла пусто
	//вся полезная работа делается в ходе проверки условия
	//за счёт инкремента
	while (str[i++]);

	//не забываем про коррекцию
	return (i - 1);
}

char* str_cpy(char* dst, char* src)
{
	/*
	Функция копирования строк
	содержимое строки src (от слова source)
	пишется поверх строки dst (от слова destination)
	Реализация небезопасна!
	мы никак не проверяем,
	достаточно ли памяти выделено при объявлении dst
	Считается, что такого рода проверку программист
	должен сделать самостоятельно перед вызовом функции
	*/

	unsigned i = 0;
	do
		dst[i] = src[i];
	while (src[i++]);

	//как правило все функции обработки строк возвращают
	//указатель на char, который ссылается на строку-результат
	//это позволяет в месте вызова тут же воспользоваться результатом
	return dst;
}

char* str_cat(char* str1, char* str2)
{
	/*
	Функция конкатенации (сцепления) строк
	содержимое строки str2 дописывается 
	после str1
	Реализация небезопасна!
	мы никак не проверяем,
	достаточно ли памяти выделено при объявлении str1
	Считается, что такого рода проверку программист
	должен сделать самостоятельно перед вызовом функции
	*/
	
	/*
	можно организовать копирование посимвольно
	важно только правильно посчитать,
	с какой позиции в первой строке
	нужно начинать копировать
	символы второй строки
	мы должны стереть символ '\0' в первой строке,
	записав на его место стартовый символ второй строки

	unsigned str1_len = str_len(str1);
	unsigned i = 0;
	do
		str1[i + str1_len] = str2[i];
	while (str2[i++]);
	
	return str1;*/

	//можно свести реализацию сцепления к копированию
	//копируем вторую строку по адресу,
	//соответствующему символу конца строки в str1
	return str_cpy(str1 + str_len(str1), str2);
}

int str_cmp(char* str1, char* str2)
{
	/*
	Функция для сравнения строк
	строки сравниваются посимвольно
	если они полностью совпадают - возвращается 0
	если в паре несовпадающих символов больше код символа,
	стоящего в первой строке - возвращаеся положительное число,
	в противном случае - отрицательное
	*/
	unsigned i = 0;
	int delta;


	//используем разность кодов символов
	//как основной критерий продолжения цикла
	do
	{
		delta = str1[i] - str2[i];
	} while (!delta && str1[i++]);
	//кроме того при завершении первой строки также выходим
	//если же вторая строка завершиться раньше,
	//то сработает выход по delta
	
	return (delta);
}

char* str_str(char* str, char* sub)
{
	/*
	Функция поиска подстроки (sub) в строке (str)
	возвращает указатель на символ,
	с которого начинается первое вхождение подстроки
	если вхождения нет, возвращаем NULL
	*/

	unsigned i = 0, j, flag;

	do
	{
		j = 0;
		flag = 1;
		do 
			//если нашли несовпадающие символы
			if (str[i + j] != sub[j])
			{
				//сбросили флаг и вышли
				flag = 0;
				break;
			}
		//обращаем внимание, что увеличение j здесь выполняется
		//ПЕРЕД проверной условия продолдения цикла
		while (sub[++j]);
		//если в процессе сравнения флаг не был сброшен,
		//то мы нашли искомую позицию
		if (flag) return (str+i);
	} while (str[i++]);

	return NULL;
}

char* remove_char(char* str, unsigned pos)
{
	/*
	Функция удаления символа с заданным индексом
	*/

	//реализцетя по сути сдвиг вправо,
	//начиная с заданной позиции
	do
		str[pos] = str[pos + 1];
	while (str[pos++]);
	//только цикл организоваy на основе проверки на '\0'

	//и возвращаем char*,
	//как это обычно делается в функциях обработки строк
	return str;
}

char* remove_duplicates(char* str)
{
	/*
	Функция удаления повторных вхождений символов в строку
	Простейшие реализации обычно основаны
	на удалении найденных повторных символов,
	что приводит к многократным сдвигам массива
	В данной реализации повторные символы не удаляются,
	а просто пропускаются.
	Зато впервые встреченные символы копируются в начало строки.
	Т.е. в начале строки начинает формироваться ответ,
	по завершении обработки всей строки после него надо будет
	только дописать '\0'.
	Тем самым мы не только избегаем сдвигов,
	но и упрощаем процедуру проверки на дубликаты.
	Уникальных символов заведомо не может быть больше,
	чем всего символов в кодовой таблице (255).
	А строка при этом может быть гораздо длиннее.
	Важно заметить, что в общем случае счётчик символов i
	обгоняет счётчик уникальных символов count,
	но между ними располагаются дублирующиеся элементы,
	поэтому на их место можно смело записывать новые обнаруженные
	уникальные элементы
	*/

	unsigned count = 1, i = 0, j, flag;
	
	while (str[i])
	{
		flag = 1;
		//проверка на унивальность
		//поиск среди первых (count-1) элементов
		for (j=0; j < count; j++)
			if (str[j] == str[i])
			{
				flag = 0;
				break;
			}
		//если флаг не сброшен
		if (flag)
			//добавляем символ к числу уникальных			
			str[count++] = str[i];
		i++;
	}
	str[count] = '\0';

	return str;

}

unsigned sum_of_digits(char* str)
{
	/*
	Функция вычисления суммы ЦИФР,
	входящих в состав строки
	*/
	unsigned i = 0, sum = 0;

	do
		//если символ является цифрой
		if (str[i] >= '0' && str[i] <= '9')
			//добавляем значение цифры к сумме
			//поскольку в кодовой таблице цифры
			//записаны подряд, числовое значение
			//можно получить вычислив разность
			//кода текущего символа с кодом символа '0'
			sum += str[i] - '0';
	while (str[i++]);

	return sum;
}

unsigned sum_of_decimals(char* str)
{
	/*
	Функция вычисления суммы ЧИСЕЛ,
	входящих в состав строки
	*/

	unsigned i = 0, sum = 0, decimal = 0;

	do
	{
		//пока встречаем в подряд идущие цифры
		while (str[i] >= '0' && str[i] <= '9')
		{
			//формируем число
			decimal = decimal * 10 + (str[i] - '0');
			i++;
		}
		//если символ не цифра
		//добавляем подсчитанное число к сумме
		sum += decimal;
		//и готовимся читать следующее число
		decimal = 0;
	}
	while (str[i++]);

	return sum;
}

void swap(char* pa, char* pb)
{
	char temp = *pa;
	*pa = *pb;
	*pb = temp;
}

char* reverse_string(char* str)
{
	/*
	Переворот строки
	*/

	//сводится к перевороту подстроки,
	//но захватывая все элементы строки
	return reverse_substring(str, 0, str_len(str)-1);
}

char* reverse_substring(char* str, int left, int right)
{
	/*
	Переворот подстроки
	В начале возможно добавление проверки
	на корректность исходных данных
	(left и right)
	*/

	while (left < right)
		swap(str + left++, str + right--);
	
	return str;
}

unsigned char_in_string(char symbol, char* str)
{
	/*
	Функция проверяет, встречается ли символ в строке
	Если встречается - возвращаем 1, если нет - 0
	Важно!!! Функция написана так,
	чтобы анализировать и символ '\0',
	который неявно существует в любой строке в C
	*/
	unsigned i = 0;
	
	do
		if (str[i] == symbol)
			return 1;
	while (str[i++]);
	//при такой организации цикла проверяется и символ '\0'

	return 0;
}

unsigned words_count(char* str)
{
	/*
	Функция расчёта числа слов в строке
	Слова отделяются символами-разделителями,
	которые для удобства сгруппированы в отдельную
	строку separator. В некоторых случаях удобно
	передавать такую строку как второй аргумент функции.
	При написании подобных функций важно помнить,
	что она должна быть устойчива к появлению разделителей
	в начале строки, нескольких разделителей вподряд,
	корректно обрабатывать слово, за которым следует
	конец строки
	*/

	unsigned inWord = 0, i = 0, count = 0;
	char separator[] = " \t,.!?:;";

	do
	{
		if (char_in_string(str[i], separator))
		{
			if (inWord)
				count++;
			inWord = 0;
		}
		else
			inWord = 1;
	} while (str[i++]);
	//при этом символ '\0' тоже будет обработан

	return count;
}

unsigned longest_word(char* str)
{
	/*
	Функция нахождения длины самого длинного слова
	Общие принципы организации - аналогичны подсчёту
	числа слов в строке (см. функцию words_count).
	Проходя по строке,
	будем считать длину каждого очередного слова.
	Если она окажется больше текущей оценки
	максимальной длины - обновляем эту оценку.
	Изначально оценку полагаем равной 0.
	*/

	unsigned inWord = 0, i = 0, length = 0, maxLength = 0;
	char separator[] = " \t,.!?:;";

	do
	{
		if (char_in_string(str[i], separator))
		{
			if (inWord)
				if (length > maxLength)
					maxLength = length;
			inWord = 0;
			length = 0;
		}
		else
		{
			inWord = 1;
			length++;
		}
	} while (str[i++]);
	//при этом символ '\0' тоже будет обработан

	return maxLength;
}

unsigned shortest_word(char* str)
{
	/*
	Функция нахождения длины самого короткого слова
	Общие принципы организации - аналогичны подсчёту
	числа слов в строке (см. функцию words_count).
	Проходя по строке,
	будем считать длину каждого очередного слова.
	Если она окажется меньше текущей оценки
	минимальной длины - обновляем эту оценку	
	Изначально оценку полагаем равной 0.
	Если при сравнении этих величин понимаем,
	что оценка до сих пор нулевая
	(т.е. прочитанное слово является первым),
	то его длину принимаем за оценку минимальной длины.
	*/

	unsigned inWord = 0, i = 0, length = 0, minLength = 0;
	char separator[] = " \t,.!?:;";

	do
	{
		if (char_in_string(str[i], separator))
		{
			if (inWord)
				if ((length < minLength) || !minLength)
					minLength = length;
			inWord = 0;
			length = 0;
		}
		else
		{
			inWord = 1;
			length++;
		}
	} while (str[i++]);
	//при этом символ '\0' тоже будет обработан

	return minLength;
}

void print_words(char* str)
{
	/*
	Функция печатает слова, образующие строку,
	в отдельных строках потока вывода
	(отделяя их символом '\n').
	Общие принципы организации - аналогичны подсчёту
	числа слов в строке (см. функцию words_count).
	*/

	unsigned inWord = 0, i = 0;
	char separator[] = " \t,.!?:;";

	do
	{
		if (char_in_string(str[i], separator))
		{
			if (inWord)
				putchar('\n');
			inWord = 0;
		}
		else
		{
			inWord = 1;
			putchar(str[i]);
		}
	} while (str[i++]);
	//при этом символ '\0' тоже будет обработан
}

char* reverse_words(char* str)
{
	/*
	Функция обнаруживает слова в строке
	и переставляет все символы в каждом
	из них в обратном порядке.
	Общие принципы организации - аналогичны подсчёту
	числа слов в строке (см. функцию words_count).
	Важно, что в данном случае фиксируются индексы
	начала слова (left) и конца слова (right).
	Они передаются как аргументы ранее написанной
	функции reverse_substring.
	*/

	unsigned inWord = 0, i = 0, left=0, right=0;
	char separator[] = " \t,.!?:;";

	do
	{
		if (char_in_string(str[i], separator))
		{
			if (inWord)
			{
				right = i - 1;
				reverse_substring(str, left, right);
			}
			inWord = 0;
		}
		else
		{
			if (!inWord)
			{
				left = i;
				inWord = 1;
			}
			
		}
	} while (str[i++]);
	//при этом символ '\0' тоже будет обработан

	return str;
}
//*************************************************************************************************************
#include <stdio.h>

//метод str_len, возвращает длинну строки
int str_len(char* str) {
	
    int i = 0;
    while (str[i++] != '\0');
    return i-1;//т.к. отсчет начинался с 0
    
}

//метод str_cpy, посимвольно копирует строку src в dst, возвращая скопированную строку
	//небезопасен, т.к. отсутствует проверка на переполнение памяти
char* str_cpy(char* dst, char* src){
	
	unsigned i = 0;
	do
		dst[i] = src[i];
	while (src[i++]);
	return dst;

}

//метод str_cat, содержимое строки str1 дописывается после str1
	//небезопасен, т.к. отсутствует проверка на переполнение памяти
char* str_cat(char* str1, char* str2){

	unsigned str1_len = str_len(str1);//используем ранее изученный метод str_len
	unsigned i = 0;
	
	do
		str1[i + str1_len] = str2[i];
	while (str2[i++]);
	
	return str1;
	
return str_cpy(str1 + str_len(str1), str2);
}

//метод str_cmp, сравнивает 2 строки посимвольно, возвращая величину int !
	//Случай 1: строки абсолютно идентичны, возвращай 0
	//Случай 2: символ строки str1 больше по кодировке, чем символ строки str2, возвращай число>0
	//Случай 3: символ строки str2 больше по кодировке, чем символ строки str1, возвращай число<0
int str_cmp(char* str1, char* str2){

	unsigned i = 0;
	int delta;

	do
	{
		delta = str1[i] - str2[i];
	} while (!delta && str1[i++]);
	//while идет на новый круг только тогда, когда delta=0 - > !delta=1 -> 1&&1=1 -> след. круг
	//если delta !=0, то есть delta=1, тогда !delta=0 и 0&&1=0, цикл остановится
	return (delta); 
}

//метод str_str, ищет строку sub в строке str, 
	//возвращает указатель на символ с которого началось совпадение, 
	//в случае отсутствия возвращает значнеи NULL
char* str_str(char* str, char* sub){
	
	unsigned i = 0, j, flag;

	do
	{
		j = 0;
		flag = 1;
		do 
			//если нашли несовпадающие символы
			if (str[i + j] != sub[j])
			{
				//сбросили флаг и вышли
				flag = 0;
				break;
			}
		
		while (sub[++j]);//увеличиваем перед проверкой условия
		if (flag) 
			return (str+i);
	} while (str[i++]);

	return NULL;
}

//метод char_in_string, проверяет, есть ли в строке символ symbol или нет
	//возвращая 1, если есть или 0, если нет
	//нужен для проверки наличия '\0' в строке
unsigned char_in_string(char symbol, char* str){
	
	unsigned i = 0;
	
	do
		if (str[i] == symbol)
			return 1;
	while (str[i++]);

	return 0;
}

//метод s_gets на базе fgets
	//безопасная с точки зрения переполнения буфера
	//реализация чтения строки с консоли
		//Функция fgets() считывает до num-1 символов из файла stream
		//и помещает их в массив символов, на который указывает str. 
		//Символы считываются до тех пор, пока не встретится символ «новая строка»
		//Чтение происходит из файла.
char* s_gets(char* str, unsigned buf_size){

	unsigned i = 0;
	//если вызов fgets завершился возвратом NULL
	if (!fgets(str, buf_size, stdin))//функцию fgets вы уже знаете
		return NULL;

	do
		if (str[i] == '\n')
			break;
	while (str[++i]);
	
	str[i] = '\0';

	while (getchar() != '\n');

	return str;
}

//метод s_gets_c на базе getchar
//безопасная с точки зрения переполнения буфера
//Основана на посимвольном чтении потока ввода (getchar)
char* s_gets_c(char* str, unsigned buf_size){
	
	unsigned i = 0;
	int ch;

	//в данном случае из потока ввода забираем всё,
	// что есть до символа '\n' (когда будет нажат ввод)
	while ((ch = getchar()) != '\n')
		//но записываем только пока есть место в строке
		if (i < (buf_size - 1))
			str[i++] = ch;
	//в конце не забываем поставить символ конца строки
	str[i] = '\0';
		
	return str;
}


int main(void) {

	//создадим в качестве входных данных 3 строки
	char A[] = "aaaa";
	char B[] = "bbbb";
	char C[] = "c";
	char empty[50];
	
	//применение метода str_len
	int len; 
    len = str_len(A);
	printf("length of A: %d\n", len); 
	
	//применение метода str_сpy
    str_cpy(B,A);// мы записали значение А в В
	printf("str_cpy result: %s\n", B);//не забываем, что тип str и поэтому %s !
	
	//применение метода str_cat
    str_cat(B,C);
	printf("str_cat result: %s\n", B);// str B + str C = aaaac (выше мы изменили значение str B)
	
	//применение метода str_cmp
	int i1 = str_cmp(A,A);//0
	int i2 = str_cmp(B,A);//>0
	int i3 = str_cmp(A,C);//<0
	
	printf("str_cmp result: 1) %d\n", i1);// не забудь про %d
	printf("str_cmp result: 2) %d\n", i2);// не забудь про %d
	printf("str_cmp result: 3) %d\n", i3);// не забудь про %d
	
	//применение метода str_str
	printf("str_str result: %s\n", str_str(B, C));	//повтор sub (в нашем случае C) 
													//в str (в нашем случае В) начинается с 'с'
	printf("str_str result: %s\n", str_str(A, C));	//'c' отсутствует в A, возвращаем (null)
	
	//применение char_in_string
	unsigned char symbol = '\0';
	printf("char_in_string result: %d\n", char_in_string(symbol, A));//%d т.к. в return значенеи int 
	
	return 0;
}
